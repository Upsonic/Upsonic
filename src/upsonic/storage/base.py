from abc import ABC, abstractmethod
from typing import List, Literal, Optional, Generator

from upsonic.storage.session.llm import LLMConversation, LLMTurn, Artifact 



class SchemaMismatchError(Exception):
    """
    Custom exception raised when the database schema does not match the
    application's expected schema (ORM models).
    """
    pass


class Storage(ABC):
    """
    The "Contract" for an LLM Interaction Archive.

    This Abstract Base Class defines the universal API for persisting and
    retrieving LLM conversations. The contract is designed around an append-only
    model, where conversations are started and then turns are appended, which
    is a natural fit for LLM chat and workflow applications.
    """

    def __init__(self):
        self._mode: Optional[Literal["agent", "team", "workflow", "workflow_v2"]] = None
        self._connected = False


    @property
    def mode(self) -> Optional[Literal["agent", "team", "workflow", "workflow_v2"]]:
        """Get the mode or namespace of the storage instance."""
        return self._mode

    def _set_mode(self, value: Literal["agent", "team", "workflow", "workflow_v2"]) -> None:
        """Set the mode of the storage."""
        self._mode = value

    
    @abstractmethod
    def is_connected(self) -> bool:
        """Checks if the storage provider is currently connected."""
        raise NotImplementedError

    @abstractmethod
    def connect(self) -> None:
        """
        Establishes and verifies the connection to the storage backend.
        For SQL providers, this also handles initial schema creation and verification.
        """
        raise NotImplementedError

    @abstractmethod
    def disconnect(self) -> None:
        """Closes the connection to the storage backend gracefully."""
        raise NotImplementedError


    @abstractmethod
    def start_conversation(self, conversation: LLMConversation) -> None:
        """
        Creates the initial record for a new conversation.

        This method should atomically insert the conversation's metadata
        (e.g., conversation_id, user_id, created_at). The `turns` list
        within the conversation object will typically be empty at this stage.

        Args:
            conversation: The LLMConversation object to create.
        """
        raise NotImplementedError

    @abstractmethod
    def append_turn(self, conversation_id: str, turn: LLMTurn) -> None:
        """
        Appends a single LLMTurn to an existing conversation.

        This is the primary write method for ongoing conversations. It should
        be an atomic and efficient operation (e.g., a single INSERT or XADD).

        Args:
            conversation_id: The ID of the conversation to append to.
            turn: The LLMTurn object to add.
        """
        raise NotImplementedError

    @abstractmethod
    def log_artifact(self, artifact: Artifact) -> None:
        """
        Records the metadata of an artifact associated with a conversation.

        This method saves the pointer (URI) and metadata for an artifact,
        linking it to a conversation and optionally a specific turn.

        Args:
            artifact: The Artifact metadata object to save.
        """
        raise NotImplementedError
    
    @abstractmethod
    def store_artifact_data(self, artifact_id: str, conversation_id: str, binary_data: bytes) -> str:
        """
        Stores the raw binary data of an artifact and returns its access URI.

        This method handles the physical storage of the file's bytes, whether
        in memory, on disk, or in a blob store. It is the "write" operation
        for the data itself.

        Args:
            artifact_id: The unique ID of the artifact being stored.
            conversation_id: The ID of the conversation for namespacing/organization.
            binary_data: The raw bytes of the file to store.

        Returns:
            A unique storage URI (e.g., "memory://<id>", "file:///path/to/file")
            that the provider can use later to retrieve the data.
        """
        raise NotImplementedError

    @abstractmethod
    def retrieve_artifact_data(self, storage_uri: str) -> bytes:
        """
        Retrieves the raw binary data of an artifact using its storage URI.

        This method is the "read" operation for the data itself, using the
        pointer provided by store_artifact_data.

        Args:
            storage_uri: The unique storage URI generated by the same provider.

        Returns:
            The raw bytes of the artifact.

        Raises:
            FileNotFoundError: If no artifact data can be found for the given URI.
        """
        raise NotImplementedError

    @abstractmethod
    def get_conversation(self, conversation_id: str) -> Optional[LLMConversation]:
        """
        Retrieves a full conversation, including all of its turns.

        This is the primary read method. It should fetch the conversation's
        metadata and reconstruct the complete, ordered history of its turns.

        Args:
            conversation_id: The ID of the conversation to retrieve.

        Returns:
            An LLMConversation object with the `turns` list fully populated,
            or None if the conversation is not found.
        """
        raise NotImplementedError
    
    @abstractmethod
    def list_conversations(
        self,
        user_id: Optional[str] = None,
        entity_id: Optional[str] = None,
        limit: int = 20,
        offset: int = 0
    ) -> List[LLMConversation]:
        """
        Lists conversations with optional filtering, for display in a UI.

        For performance, the `LLMConversation` objects returned by this method
        SHOULD NOT contain the full list of turns. The `turns` list should
        be empty or contain only a small, recent subset.

        Args:
            user_id: Filter conversations by user ID.
            entity_id: Filter conversations by entity ID.
            limit: The maximum number of conversations to return.
            offset: The number of conversations to skip (for pagination).

        Returns:
            A list of LLMConversation objects, sorted by most recently updated.
        """
        raise NotImplementedError


    def stream_turns(self, conversation_id: str) -> Generator[LLMTurn, None, None]:
        """
        (Advanced) Yields turns from a conversation one by one.

        This is a memory-efficient alternative to `get_conversation` for
        processing very long conversation histories. Concrete implementations
        are not required to implement this and can raise NotImplementedError.

        Args:
            conversation_id: The ID of the conversation to stream.

        Yields:
            LLMTurn objects in chronological order.
        """
        raise NotImplementedError


    @abstractmethod
    def drop(self) -> None:
        """
        Deletes ALL data from the storage provider corresponding to the current
        configuration. This is a destructive operation.
        """
        raise NotImplementedError